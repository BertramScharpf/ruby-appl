#!/usr/local/bin/ruby

#
#  intar  --  Interactive Ruby evaluation
#

require "intar"
require "appl"


class IntarApp < Application

  NAME      = "intar"
  VERSION   = "1.0"
  SUMMARY   = "Interactive Ruby"
  COPYRIGHT = "(C) 2008-2013 Bertram Scharpf <software@bertram-scharpf.de>"
  LICENSE   = "BSD"
  AUTHOR    = "Bertram Scharpf <software@bertram-scharpf.de>"

  DESCRIPTION = <<EOT
Prompt for Ruby statements, evaluate them. This is a replacement
for "irb". The underlying library may be entered from inside any
Ruby program.

Example:

  $ intar -p '%(33 1)c%t%c%> '

EOT

  def quiet!
    Intar.show = nil
  end
  def show= s
    Intar.show = s.to_i
  end
  def prompt= p
    Intar.prompt = p if p
  end
  def bw!
    Intar.colour = false
  end
  def catch_exit!
    Intar.catch_exit = (Intar.catch_exit||0) + 3
  end
  def histall!
    Intar.histhid = false
  end
  def histfile= h
    is_none? h do h = nil end
    Intar.histfile = h
  end
  def histmax= m
    Intar.histmax = (Integer m rescue m.to_i)
  end
  def configfile= c
    is_none? c do c = nil end
    @configfile = c
  end

  define_option "p", :prompt=, "STR",
                              "prompt - see source code for % escapes"
  alias_option  "p", "prompt"

  define_option "q", :quiet!,                     "don't show results"
  alias_option  "q", "quiet"

  define_option "S", :show=, "N", 1,  "show result line limit (0=all)"
  alias_option  "S", "show"

  define_option "r", :require, "FILE",                  "Ruby require"
  alias_option  "r", "require"

  define_option "bw", :bw!,                            "black & white"

  define_option "c", :configfile=, "FILE", ".intarrc",
                                        "config file, NONE means none"
  alias_option  "c", "configfile"

  define_option "H", :histfile=, "FILE", ".intar_history",
                                       "history file, NONE means none"
  alias_option  "H", "histfile"

  define_option "m", :histmax=, "NUM",
                                     "maximum history entries to save"
  alias_option  "m", "histmax"

  define_option "A", :histall!,
                          "pass lines starting with blanks to history"
  alias_option  "A", "histall"

  define_option "E", :encoding=, "ENC",  "set encoding (like ruby -E)"
  alias_option  "E", "encoding"

  define_option "x", :catch_exit!,
                     "On exit exception: Wait 3 seconds for interrupt"
  alias_option  "x", "catchexit"
  alias_option  "x", "catch-exit"

  define_option "h", :help,                             "show options"
  alias_option  "h", "help"
  define_option "V", :version,                          "show version"
  alias_option  "V", "version"

  def run
    # @debug = true      # Only development.
    read_cfg
    main = eval "self", TOPLEVEL_BINDING
    Intar.open main do |i|
      i.run *(@args.shift @args.length)
    end
  end

  private

  def encoding= ei
    e, i = ei.split ":"
    Encoding.default_external = e if e and not e.empty?
    Encoding.default_internal = i if i and not i.empty?
    [ $stdin, $stdout, $stderr].each do |io|
      io.set_encoding e, i
    end
  end


  def read_cfg
    c = @configfile
    return unless c
    unless c[ File::SEPARATOR] or (File.exists? c) then
      c = File.expand_path c, "~"
      return unless File.exists? c
    end
    r = File.read c
    r.insert 0, "$SAFE = 1#$/"
    Thread.new {
      begin
        eval r, TOPLEVEL_BINDING
      rescue Exception
        $@.pop 2
        e = $@.shift
        puts "#{e}: #$! (#{$!.class})"
        $@.each { |l| puts "\t#{l}" }
        raise "Error in config file #{c}"
      end
    }.value
  end

  def is_none? var
    yield if [ "", "NONE"].include? var
  end

end

IntarApp.run

