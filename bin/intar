#!/usr/local/bin/ruby

#
#  intar  --  Interactive Ruby evaluation
#

require "intar"
require "appl"


class IntarApp < Application

  NAME      = "intar"
  VERSION   = APPL_VERSION
  SUMMARY   = "Interactive Ruby"
  COPYRIGHT = "(C) 2008-2016 Bertram Scharpf <software@bertram-scharpf.de>"
  LICENSE   = "BSD"
  AUTHOR    = "Bertram Scharpf <software@bertram-scharpf.de>"

  DESCRIPTION = <<~EOT
    Prompt for Ruby statements, evaluate them. This is a replacement
    for "irb". The underlying library may be entered from inside any
    Ruby program.

    Example:

      $ intar -p '%(33 1)c%t%c%> '

  EOT

  attr_writer :show, :prompt, :histmax
  def histfile=   f ; @histfile   = nil_if_none f ; end
  def configfile= f ; @configfile = nil_if_none f ; end
  attr_bang :quiet, :bw, :catch_exit, :histall

  define_option "p", :prompt=, "STR",
                              "prompt - see source code for % escapes"
  alias_option  "p", "prompt"

  define_option "q", :quiet!,                     "don't show results"
  alias_option  "q", "quiet"

  define_option "s", :show=, "N",     "show result line limit (0=all)"
  alias_option  "s", "show"

  define_option "r", :require, "FILE",                  "Ruby require"
  alias_option  "r", "require"

  define_option "bw", :bw!,                            "black & white"

  define_option "c", :configfile=, "FILE", ".intarrc",
                                        "config file, NONE means none"
  alias_option  "c", "configfile"

  define_option "H", :histfile=, "FILE", ".intar_history",
                                       "history file, NONE means none"
  alias_option  "H", "histfile"

  define_option "m", :histmax=, "NUM",
                                     "maximum history entries to save"
  alias_option  "m", "histmax"

  define_option "A", :histall!,
                          "pass lines starting with blanks to history"
  alias_option  "A", "histall"

  define_option "E", :encoding=, "ENC",  "set encoding (like ruby -E)"
  alias_option  "E", "encoding"

  define_option "x", :catch_exit!,
                     "On exit exception: Wait 3 seconds for interrupt"
  alias_option  "x", "catchexit"
  alias_option  "x", "catch-exit"

  define_option "h", :help,                             "show options"
  alias_option  "h", "help"
  define_option "V", :version,                          "show version"
  alias_option  "V", "version"

  def run
    # @debug = true      # Only development.
    read_cfg
    if @quiet then
      Intar.show = 0
    elsif @show then
      Intar.show = Integer @show
    end
    Intar.prompt = @prompt if @prompt
    Intar.colour = false if @bw
    Intar.catch_exit = (Intar.catch_exit||0) + 3 if @catch_exit
    Intar.histhid = false if @histall
    Intar.histfile = @histfile if @histfile
    Intar.histmax = Integer @histmax if @histmax

    main = eval "self", TOPLEVEL_BINDING
    Intar.open main do |i|
      i.run *(@args.shift @args.length)
    end
  end

  private

  def encoding= ei
    e, i = ei.split ":"
    Encoding.default_external = e if e and not e.empty?
    Encoding.default_internal = i if i and not i.empty?
    [ $stdin, $stdout, $stderr].each do |io|
      io.set_encoding e, i
    end
  end

  def read_cfg
    return unless @configfile
    h = "~" unless @configfile[ File::SEPARATOR]
    c = File.expand_path @configfile, h
    return unless File.exists? c
    load c
  rescue Exception
    $@.pop 2
    e = $@.shift
    puts "#{e}: #$! (#{$!.class})"
    $@.each { |l| puts "\t#{l}" }
    raise "Error in config file #{c}"
  end

  def nil_if_none var
    case var
      when "", "NONE" then nil
      else                 var
    end
  end

end

IntarApp.run

